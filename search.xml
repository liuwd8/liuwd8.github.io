<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统分析与设计-作业7]]></title>
    <url>%2F2019%2F05%2F26%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-作业6]]></title>
    <url>%2F2019%2F05%2F26%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A6%2F</url>
    <content type="text"><![CDATA[简答题 什么是用例?用例（use case），或使用案例、用况，是软件工程或系统工程中对系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。每个用例提供了一个或多个场景，该场景说明了系统是如何和最终用户或其它系统互动，也就是谁可以用系统做什么，从而获得一个明确的业务目标。编写用例时要避免使用技术术语，而应该用最终用户或者领域专家的语言。用例一般是由软件开发者和最终用户共同创作的。 用例和场景的关系?什么是主场景或 happy path? 用例(use case)和场景(scenario)的关系：用例表示一组场景(a collection of scenarios)，场景属于用例的实例。 主场景(the primary scenario)或happy path：用例从触发事件开始，一步一步执行，最终满足用例利益的步骤集合；应该包含以下信息： 两个执行者之间的交互。如，用户提交了订单。 为保证主成功场景得以继续的确认。如，系统确认用户密码。 主成功场景推进过程中的内部变化。如，系统扣除用户账户余额。 用例有哪些形式? Brief(high level): 一段简单的概要，通常是主要成功案例。主要在早期需求分析中，快速了解主题和范围，创作可能只需几分钟 Casual(简便格式): 非正式格式，涵盖各种场景的多个段落，主要在早期需求分析中使用 Fully: 所有的步骤和变化都写得很详细，并有支持部分，如前提条件和成功保证。主要在确定了许多用例并以简短格式编写后，详细编写了一些具有架构意义和高价值的用例 对于复杂业务，为什么编制完整用例非常难?复杂业务涉及到的场景比较多，业务流程复杂繁琐，不同场景之间存在关联，系统交互比较复杂，需要考虑的备选流众多，因此编制完整用例非常难 什么是用例图?用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图是外部用户（被称为参与者）所能观察到的系统功能的模型图。用例图是系统的蓝图。用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。 用例图的基本符号与元素? 参与者(Actor) - 表示的是一个系统用户，也就是与应用程序进行交互的用户. 组织或者外部系统 用例(Use Case) - 表示的是对系统提供的功能. 服务的一种描述 用例之间的关系包含关系(Include) - 表示用例可以简单地包含其他用例所具有的行为，并把它所包含的用例行为作为自身行为的一部分。在UML中常用带箭头的虚线表示，箭头指向被包含的用例 泛化关系(Generalization) - 泛化指的是一个父用例可以被特化形成多个子用例，而父用例和子用例之间的关系就是泛化关系。在UML中用空心三角箭头的实线表示，箭头指向父用例 扩展/延伸关系(Extend) - 表示在一定条件下，把新的行为加入到已有的用例中，获得的新用例叫做扩展用例，原有的用例叫做基础用例，相当于为基础用例提供一个附加功能。在UML中用带箭头的虚线表示，箭头指向基础用例 关联关系(Association) - 表示的是参与者与用例之间的关系。在UML中常用一条直线，或者是一条带箭头的线条来表示，箭头指向信息接收方 子系统(Subsystem) — 用来展示系统的一部分功能，这部分功能联系紧密 用例图的画法与步骤 确定参与者，包括:主要参与者：谁将使用系统的主要功能. 谁将需要系统的支持以完成工作等 协作参与者：谁将提供对应的系统功能. 谁将维护系统，保证系统处于工作状态等 幕后参与者：谁会对系统产生的结果感兴趣 根据用户需求识别和创作用例，主要重点在于： 识别使用系统的主要参与者（primary actors）/角色(roles) 识别系统依赖的外部系统 识别用例（服务） 识别用户级别用例（user goal level） 识别子功能级别的用例（sub function level） 建立 Actor 和 Use Cases 之间的关联。 用例图给利益相关人与开发者的价值有哪些对于利益相关人： 对于利益相关人而言 可以直观看到系统的结果和用户的功能体验，保证系统按照用户的需求进行设计。 用例能够根据需要对复杂程度和形式化程序进行增减调节，即能够响应用户（利益相关人)提出的需求，而用例图则使得这种调节更加便利，可以通过修改图形间的关系实现。 对于开发者来说： 用例图是设计者设计过程的结论与参考，设计者与开发者之间的交流工具，开发者开发过程的蓝图。 用例图使得开发者能够更明确地获得需求，更好地理解需求。 用例图可以指导开发和测试，同时可以在整个过程中对其他工作流起到指导作用。 建模练习题（用例模型） 选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程. 去哪儿等）. 定电影票. 背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务答: 百词斩 百词斩 然后，回答下列问题： 为什么相似系统的用例图是相似的？相似系统面对的参与者和用例是相似的，用例之间的关系也是同构的。用户预期的功能都是相似的，即不同的同类系统一定具有一致基本功能以及带有自己特色的扩展功能。所以体现在用例图上也是相似的。 如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代. 不同地区产品的用例图，展现. 突出创新业务和技术不同时代. 不同地区用户习惯. 需求法规以及其他社会环境的不同，使得技术和业务需求方面有所差距，这些差异会体现在用例图中，可以用不同的色彩标注他们来突出创新之处。 如何利用用例图定位创新思路（业务创新. 或技术创新. 或商业模式创新）在系统中的作用用例图中的每个用例之间的关系都是明确的，我们可以对其中相对独立，即入度出度都比较小的用例进行创新，这样对系统整体的影响就不会很大。创新的角度可以是删去这个用例或者是给这个用例添加新功能。 请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表 ID Name Imp Est How to demo 1 登录 5 3 人脸识别登录 2 查询酒店 7 10 通过位置. 地图筛选，或直接通过酒店名查找酒店，同时可以做简单预测 3 预订酒店 5 14 选择酒店. 挑选房间并进行预定 4 支付 7 14 提交订单，使用银行卡或者其他支付方式支付 根据任务4，参考使用用例点估算软件成本，给出项目用例点的估算。根据用户点方法，对用例分配权重的标准是： 简单用例：1 到 3 个事务，权重=5 一般用例：4 到 7 个事务，权重=10 复杂用例：多于 7 个事务，权重=15 用例 事务 计算 UC权重 登陆 1 1 简单 查询酒店 3 3 一般 预订酒店 3 3 一般 支付 2 2 简单]]></content>
      <categories>
        <category>System analysis and design</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-作业3]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A3%2F</url>
    <content type="text"><![CDATA[简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点 瀑布模型（Waterfall Model） 是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈，因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，项目开发进程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来。 优点 为项目提供了按阶段划分的检查点。 当前一阶段完成后，您只需要去关注后续阶段。 可在迭代模型中应用瀑布模型。 它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。 缺点 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。 通过过多的强制完成日期和里程碑来跟踪各个项目阶段。 瀑布模型的突出缺点是不适应用户需求的变化。 增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程。 优点 将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时了解软件项目的进展。 以组件为单位进行开发降低了软件开发的风险。一个开发周期内的错误不会影响到整个软件系统。 开发顺序灵活。开发人员可以对组件的实现顺序进行优先级排序，先完成需求稳定的核心组件。当组件的优先级发生变化时，还能及时地对实现顺序进行调整。 缺点是要求待开发的软件系统可以被模块化。如果待开发的软件系统很难被模块化，那么将会给增量开发带来很多麻烦。 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。原型法是指在获取一组基本的需求定义后，利用高级软件工具可视化的开发环境，快速地建立一个目标系统的最初版本，并把它交给用户试用、补充和修改，再进行新的版本开发。反复进行这个过程，直到得出系统的“精确解”，即用户满意为止。 优点 设计上的灵活性,可以在项目的各个阶段进行变更。 以小的分段来构建大型系统,使成本计算变得简单容易。 客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。 随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。 客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。 缺点 很难让用户确信这种演化方法的结果是可以控制的。 建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。 不适合大规模系统的开发。 开发过程管理要求高，整个开发过程要经过“修改—评价—再修改”的多次反复。 用户过早看到系统原型，误认为系统就是这个模样，易使用户失去信心。 开发人员易将原型取代系统分析。 缺乏规范化的文档资料 简述统一过程三大特点，与面向对象的方法有什么关系？三大特点： 软件开发是一个迭代过程 软件开发是由Use Case驱动的 软件开发是以架构设计（Architectural Design）为中心的 统一过程是一个面向对象且基于网络的程序开发方法论。 简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？ 先启阶段(inception):初始阶段的目标是为系统建立商业案例和确定项目的边界。初始阶段结束时是第一个重要的里程碑：生命周期目标里程碑。 细化阶段(elaboration):细化阶段的目标是分析问题领域，建立健全的体系结构基础，编制项目计划，淘汰项目中最高风险的元素。细化阶段结束是第二个重要的里程碑：生命周期的结构里程碑。 构建阶段(construction):在构建阶段,所有剩余的构件和应用程序功能被开发并集成为产品,所有的功能被详尽的测试。创建阶段结束是第三个重要的项目里程碑（初始功能里程碑）。此刻，决定是否软件、环境、用户可以运作而不会将项目暴露在高度风险下。 提交阶段(transition):目的是将软件产品交付给用户。在交付阶段的终点是第四个重要的项目里程碑，产品发布里程碑。 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？ 软件企业按固定节奏生产、固定周期发布软件产品的原因统一过程为企业按固定节奏生产、固定周期发布软件产品提供了依据。并且各种开发模型如瀑布模型和螺旋模型等被用于工程实践。软件企业可以根据其产品的实际情况选择相对应的正确的软件开发模型，从而能够更好的调度人力、资源，协调好工期、预算等因素。软件开发模型使得软件企业能够用多个里程碑对开发流程进行划分和管控。 给企业项目管理的好处 降低成本，降低项目管理难度。 企业可以按固定节奏进行生产、发布，提升企业生产力，明确企业生产方向。 在软件开发的早期就可以对关键的，影响大的风险进行处理。]]></content>
      <categories>
        <category>System analysis and design</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-作业2]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A2%2F</url>
    <content type="text"><![CDATA[用简短的语言给出对分析、设计的理解。 分析（analysis）:强调的是对问题与需求的调查研究，而不是解决方案。分析主要是通过对需求和问题的研究，进一步对项目设计的方面和功能实现进行添加和删除，初步地分析出项目面向的人群和运营模式。 设计（design）：更强调的是满足需求的概念层面的解决方案，而不是其实现。设计更多地强调我们在进行项目开发时，应该对项目包含的各个部分，各个功能实现的基本架构，以及思考功能的主次性，整体实现的复杂程度等等，设计更接近于整体的思考与构建。 用一句话描述面向对象的分析与设计的优势。 面向对象分析强调的是在问题领域内发现和描述对象（或概念），定义软件对象以及它们如何协作实现要求。 面向对象的分析与设计的优势有： 从认识论的角度面向对象方法改变了开发软件的方式； 面向对象语言使得从客观世界到计算机的语言鸿沟变窄； 使分析与设计之间的鸿沟变窄； 有助于软件的维护和复用； 有助于提高软件的质量和生产率。 简述 UML（统一建模语言）的作用。考试考哪些图？ 统一建模语言UML是用于描述、构造和文档化系统制品的可视化语言，UML能够将分析与设计的结果可视化。UML能够让开发人员与客户用图形的方式进行交流。 应用UML的方式： UML作为草图 非正式的、不完整的图，借助可视化语言的功能，用于探讨问题或者解决方案空间的复杂部分、 UML作为蓝图 相对详细的设计图，用于：逆向工程，即以UML图的方式对现有代码进行可视化，使其易于理解 代码生成 UML作为编程语言，可以完成软件系统可执行规格说明。 考试要考的图有：用例图、静态图（类图、对象图、包图）、行为图（交互图、状态图、活动图）、实现图（构件图、部署图） 从软件本质的角度，解释软件范围（需求）控制的可行性 软件的本质：复杂性、一致性、可变性、不可见性。 软件的复杂性：计算机存在很多种状态，使得软件的构思、描述以及测试都非常困难。同时软件系统状态比计算机状态多若干个数量级，这些元素以非线性递增的方式交互，因此整个软件复杂度要比非线性增长多得多。 软件的一致性：开发的软件必须遵循各种接口，软件开发的目标是兼容性，许多复杂性来自于其他接口的一致性。对软件的任何再设计，都无法简化这些复杂特性。 软件的可变性： 软件实体经常会遭受到持续的变更压力。软件产品扎根于文化的母体中，如各种应用、用户、自然及社会规律、计算机硬件等。后者持续不断的变化着，这些变化无情地强迫着软件也随之变化。 软件的不可见性：软件的客观存在不具有空间的形体特征。所以如果我们使用图形来描述软件结构时，这些图形可能代表控制流程、数据流、依赖关系、时间序列和名字空间的相互关系等。即使我们在结构的建立上强制将关联分，软件仍然保持着无法可视化的固有特性。 因此，软件范围管理是非常重要的，我们可以使用二八法则进行软件的范围控制。范围控制，即监控项目的范围状态，管理范围变更。目的是在出现范围变更需求后，管理相关的计划、资源安排以及项目成果，使得项目各部分可以很好地配合在一起。 对于软件，因为其可变性，变更是不可避免的，为防止范围蔓延，在每个项目上，都必须强制实施软件的范围控制。范围控制的方式是通过变更控制系统和配置管理系统，当出现范围变更需求时，通常要执行一个严格的变更控制流程。 看板使用练习(结合Git Project) UML绘图工具练习P188 图16-8]]></content>
      <categories>
        <category>System analysis and design</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计-作业1]]></title>
    <url>%2F2019%2F03%2F11%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A1%2F</url>
    <content type="text"><![CDATA[软件工程的定义软件工程是: 将系统化的. 严格约束的. 可量化的方法应用于软件的开发. 运行和维护，即将工程化应用于软件; 在1中所述方法的研究 解释导致 software crisis 本质原因. 表现，述说克服软件危机的方法软件危机的本质是落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题。危机以几种方式表现出来： 项目运行超预算 项目运行时间过长 软件效率很低 软件质量很差 软件通常不符合要求 项目难以管理，代码难以维护 软件从未交付过 克服危机的方法： 用现代工程的概念，原理，技术和方法进行计算机软件的开发，管理和维护，由此诞生了软件工程。 软件工程是用工程，科学和数学的原则与方法来研制，维护计算机软件的有关技术及管理方法。 软件生命周期软件生命周期(Software Life Cycle,SLC)是软件的产生直到报废或停止使用的生命周期。 SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明. 软件要求软件要求KA关注软件需求的启发，协商，分析，规范和验证。在软件行业中，人们普遍认为，当这些活动表现不佳时，软件工程项目非常容易受到攻击。软件需求表达了对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。 软件设计设计被定义为两个限定的体系结构，组件，接口，以及其它的系统或部件的特性的过程中，并[即]过程的结果（IEEE 1991. 。软件设计KA涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，其将作为其构造的基础。软件设计（结果. 必须描述软件体系结构 - 即软件如何分解和组织成组件以及这些组件之间的接口。它还必须描述能够构建它们的详细程度的组件。 软件构建软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来详细创建工作软件。软件构建KA包括与满足其要求和设计约束的软件程序开发相关的主题。该KA涵盖了软件构建基础; 管理软件建设; 建筑技术; 实际考虑; 和软件构建工具。 软件测试测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。这些测试用例是从（通常非常大的. 执行域中选择的。软件测试KA包括软件测试的基础知识; 测试技术; 人机界面测试与评估; 与测试有关的措施; 和实际考虑。 软件维护软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别称为完善，自适应和纠正性软件维护。软件维护KA包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本. ; 软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量. ; 维护过程; 软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役. ; 灾难恢复技术和软件维护工具。 软件配置管理系统的配置是硬件，固件，软件或这些的组合的功能和/或物理特征。它还可以被视为根据特定构建过程组合的特定版本的硬件，固件或软件项的集合，以满足特定目的。因此，软件配置管理（SCM. 是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理KA涵盖SCM过程的管理; 软件配置识别，控制，状态核算，审计; 软件发布管理和交付; 软件工程管理软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理KA涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订. ; 软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划. ; 软件项目制定（计量，报告和控制;收购和供应商合同管理. ; 产品验收; 审查和分析项目绩效; 项目结束; 和软件管理工具。 软件工程过程软件工程KA关注软件生命周期过程的定义，实施，评估，测量，管理和改进。涵盖的主题包括流程实施和变更（流程基础架构，流程实施和变更模型以及软件流程管理. ; 流程定义（软件生命周期模型和流程，流程定义，流程适应和流程自动化的符号. ; 过程评估模型和方法; 测量（过程测量，产品测量，测量技术和测量结果的质量. ; 和软件处理工具。 软件工程模型和方法软件工程模型和方法KA解决了涵盖多个生命周期阶段的方法; 其他KAs涵盖特定生命周期阶段的特定方法。涵盖的主题包括建模（软件工程模型的原理和属性;语法与语义与不变量;前置条件，后置条件和不变量. ; 模型类型（信息，结构和行为模型. ; 分析（分析正确性，完整性，一致性，质量和相互作用;可追溯性;以及权衡分析. ; 和软件开发方法（启发式方法，形式方法，原型方法和敏捷方法. 。 软件质量软件质量是许多SWEBOK V3 KAs中普遍存在的软件生命周期问题。此外，软件质量KA还包括软件质量的基础知识（软件工程文化，软件质量特性，软件质量的价值和成本以及软件质量改进. ; 软件质量管理流程（软件质量保证，验证和确认，审核和审核. ; 和实际考虑（缺陷表征，软件质量测量和软件质量工具. 。 软件工程专业实践软件工程专业实践关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度。软件工程专业实践KA涵盖专业性（专业行为，专业协会，软件工程标准，雇佣合同和法律问题. ; 道德准则; 小组动态（团队合作，认知问题复杂性，与利益相关者互动，处理不确定性和模糊性，处理多元文化环境. ; 和沟通技巧。 软件工程经济学软件工程经济学KA关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理（提案，现金流量，货币时间价值，计划视野，通货膨胀，折旧，替代和退休决策. ; 非营利性决策（成本效益分析，优化分析. ; 估计，经济风险和不确定性（估算技术，风险决策和不确定性. ; 和多属性决策（价值和衡量尺度，补偿和非补偿技术. 。 计算基础计算基础KA涵盖了提供软件工程实践所需的计算背景的基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂性，编程基础，并行和分布式计算的基础知识，计算机组织，操作系统和网络通信。 数学基础数学基础KA涵盖了提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和功能; 基本命题和谓词逻辑; 证明技术; 图形和树木; 离散概率; 语法和有限状态机; 和数论。 工程基础工程基础KA涵盖了提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术; 统计分析; 测量和指标; 工程设计; 仿真与建模; 和根本原因分析。 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。 Level 1 - Initial: 无序, 自发生产模式. Level 2 - Repeatable：建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。 Level 3 - Defined：已将软件管理和工程两方面的过程文档化. 标准化，并综合成该组织的标准软件过程。所有项目均使用经批准. 剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。 Level 4 - Managed：分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。 Level 5 - Optimizing：过程的量化反馈和先进的新思想. 新技术促使过程持续不断改进。 用自己语言简述 SWEBok 或 CMMICMMI英文全称是Capability Maturity Model Integration，直接翻译就是能力成熟度模型。CMMI可以看作是成功企业如何做好软件的一些习惯、做法、准则等的集合，是如何做好软件的最佳实践的集合。如果企业也能按照CMMI的要求做好，那么企业就很可能成为成功的企业。公司的商业目标，简单地说两个字可以概括——“赚钱”！为了赚钱，我们有很多办法：提高质量，我们的质量不需要很高，比竞争对手高就可以了。加快进度，我们的进度也不需要很快，但至少要比竞争对手快。减少成本，成本也不必减少很多，关键是能支持公司运作，能带来利润就可以了。CMMI是为企业的商业目标服务的！既不是纯粹提高质量，也不是光增加公司的成本而不提高效益。CMMI是为了提高企业的生产力！如果贵公司实施了CMMI，而没有提高生产力的话，改进是失败的，违背CMMI的初衷的。CMMI是个好东西，我们没有做好，并不是CMMI的错，是我们没有理解好或者是执行好。要让CMMI切实为企业带来价值，难度很高。]]></content>
      <categories>
        <category>System analysis and design</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Testing</category>
      </categories>
  </entry>
</search>
